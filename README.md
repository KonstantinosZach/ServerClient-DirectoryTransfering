## 2022 Project 2

### Προσωπικά στοιχεία

__Όνομα__: Γεώργιος-Κωνσταντίνος Ζαχαρόπουλος

__Α.Μ.__: sdi1900061

### Documentation

### Σκοπός του project
Η εξοικείωση με threads και socket programming

Ένα client-server model, όπου ο σέρβερ εξυπηρετεί εν δυνάμει πολλαπλούς clients με χρήση pthreads. Oι clients επικοινωνούν με τον server μέσω sockets και ζητάνε την αντιγραφή ενός directory του server με όλα τα περιεχόμενα του.

[Αναλυτική Εκφώνηση]()

Το project έγινε στο πλαίσιο του μαθήματος [Κ24:Προγραμματισμός Συστήματος](https://cgi.di.uoa.gr/~mema/courses/k24/k24.html)

---

#### Εκτέλεση:
Έστω ότι έχουμε τα μηχανήματα linux03, linux04 και linux05 της σχολής.
* Επιλέγουμε ότι θα τρέξουμε τον server στο linux04. Βρισκόμαστε στον φάκελο serverSide και τρέχουμε την εντολή `make run`. Τώρα ο server είναι ready για να δεχτεί τα clients.
* Στα linux03 και linux05 θα τρέξουμε τους δύο clients. Σε κάθε μηχάνημα βρισκόμαστε στον φάκελο clientSide και τρέχουμε την εντολή `make run`. Ο κάθε client θα ζητήσει τον φάκελο που βρίσκεται ως όρισμα στο makefile. Προσοχή στο ip address που θα βάλουμε, θέλουμε να είναι εκείνο του server.
* Με `make clean` μπορείτε να σβήσετε τα εκτελέσιμα αρχεία αντίστοιχα σε κάθε πλευρά. Στην πλευρά του client σβήνεται και το copied directory.
* Με `make valgrind` μπορείτε να ελέγξετε για leaks.
---

### Λογική υλοποίησης:
Λογική Client:

Ο κάθε client που εκτελείται έχει την εξής δομή:
* στέλνει στον server τον όνομα του φακέλου που θέλει για αντιγραφή
* η πρώτη γραμμή μηνύματος που θα λάβει από τον server θα πρέπει να είναι το μέγεθος του φακέλου
* στην δεύτερη γραμμή το όνομα του αρχείου προς αντιγραφή
* στην τρίτη γραμμή το μέγεθος του αρχείου
* οι επόμενες θα περιέχουν το περιεχόμενο του αρχείου
* μόλις ο client διαβάσει τόσα bytes όσο και το μέγεθος του φακέλου στέλνει πίσω στον server ένα μήνυμα επαλήθευσης ότι στάλθηκε όλο το αρχείο
* διαβάζει μετά το όνομα του επόμενου αρχείου αν υπάρχει και συνεχίζει την ίδια διαδικασία
* μόλις διαβάσει όλα τα αρχεία στέλνει μήνυμα τερματισμού στον server
* κλείνει το socket και τερματίζει

Λογική Server:

O server για κάθε καινούργιο client δημιουργεί ένα communication thread το οποίο έχει τις εξής δουλειές:
* ορίζει ένα μοναδικό mutex για το αντίστοιχο client και το εισάγει στο map {socket, mutex}
* διαβάζει το όνομα του φακέλου που θέλει να αντιγράψει ο client
* στέλνει στον client το μέγεθος του φακέλου για να ξέρει ο client πόσα files να περιμένει να διαβάσει
* διατρέχει αναδρομικά τα αρχεία του φακέλου προς αντιγραφή
* προσπαθεί να lock-άρει το mutex της ουράς για να τα τοποθετήσει τα filename μαζί και με το socket του client
* όταν καταφέρει να τοποθετήσει όλα τα αρχεία στην ουρά τότε τερματίζει κάνοντας pthread_exit

Κατά το ξεκίνημα του server δημιουργείται ένας x αριθμος από worker threads που το καθένα έχει τις εξής δουλειές:
* καταρχάς το κάθε worker thread είναι ζωντανό μέχρι να σταματήσει ο server
* προσπαθεί να lock-άρει το mutex της ουράς για να πάρει το όνομα του αρχείου και το socket του client.
* μόλις τα καταφέρει προσπαθεί να lock-άρει το mutex που αντιστοιχεί στον client καθώς στον client κάθε φορά γράφει ένας worker, για αυτό και αφαιρεί το mutex του client προσωρινά από το map
* στέλνει όλο το αρχείο στον client
* περιμένει επιβεβαίωση από τον client ότι το διάβασε
* αν η επιβεβαίωση είναι ΟΚ τότε ξαναβάζει το mutex του client στο map
* αν η επιβεβαίωση είναι END τότε καταστρέφει το mutex και κλείνει το socket του client μιας και ο client τελείωσε την δουλειά του με τον server
* o worker ξαναπροσπαθεί να βρει ένα file προς αντιγραφή

Mutexes και Condition Variables:
* queue_mutex: ελέγχει την είσοδο στην ουρά από τους workers και τους communicators
* map_mutex: ελέγχει την είσοδο στο map από τους workers
* cond_queue_nonempty: ειδοποιεί τους workers όταν μπει κάποιο file στην ουρά
* cond_queue_nonfull: ειδοποιεί τους communicators για όταν βγει κάποιο file από την ουρά
* cond_map_nonempty: ειδοποιεί τους workers ότι έγινε προσθήκη κάποιου mutex στο map

### Παραδοχές:
* Το όνομα του directory(path) που θα ζητήσει ο client θα είναι έως και μεγέθους 512 bytes = (BUF_SIZE). Άμα θέλετε να τεστάρετε με μεγαλύτερο path απλά αλλάξτε το BUF_SIZE από το client.h και από το server.h
* Έχει οριστεί ο φάκελος ServerOutput για να γίνεται copy μέσα του το directory που ζήτησε ο client.
* Δεν έχει οριστεί singal handling για όταν ο server δέχεται CTRL-C από το terminal
 ---

#### Σχόλια:
* Στο project έχω βάλει και ένα φάκελο (dumps) σαν testing με dummy αρχεία. Αυτό τον φάκελο έχει ως όρισμα και το makefile του client, άμα θέλετε το αλλάζετε.
---